<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
    <title>NeHe-EPUB-06</title>
    <link type="text/css" href="../css/NeHe-EPUB.css" rel="stylesheet"/>
    <link type="text/css" href="../css/prism.css" rel="stylesheet"/>
    <script src="../js/prism.js"></script>
    <meta charset="utf-8"/>
</head>
<body>
<h2>Lesson 7 - Texture Filters and Input</h2>
<p>This lesson covers two aspects, texture filters and keyboard input. The keyboard input is rather trivial for anyone reasonably familiar with JavaScript, but texture filters are a bit more interesting. Again, three.js makes using them pretty easy, but there are a few tricks. And texture filters themselves are interesting.</p>
<p>Textures in OpenGL are made up of arrays of elements known as <em>texels</em>, which contain colour and alpha values. This corresponds with the display, which is made up of a bunch of pixels and displays a different colour at each point. In OpenGL, textures are applied to triangles and drawn on the screen, so these textures can be drawn in various sizes and orientation. The texture filtering options in OpenGL tell it how to map the texels onto the pixels of the device, depending on the scale of the mapping.</p>
<p>There are three cases:</p>
<ul>
  <li>Each texel maps onto more than one pixel. This is known as <em>magnification</em>.</li>
  <li>Each texel maps exactly onto one pixel. Filtering doesn't apply in this case.</li>
  <li>Each texel maps onto less than one pixel. This is known as <em>minification</em>.</li>
</ul>
<p>What texture filters do, then, is to tell OpenGL how to map the texels onto the pixels of the actual display. </p>
<p>There are basically two types of magnification filters:</p>
<ul>
  <li>Nearest neighbor</li>
  <li>Bilinear interpolation</li>
</ul>
<p>Nearest neighbor just finds the center of the texel nearest the center of the pixel and uses that value. The result is rather crude as the texels essentially get &quot;blown up&quot; and pixelated. Bilinear interpolation, on the other hand, does what the name says, it interpolates the value of the texel across the pixels according to the distance from the center of the texel to the center of each pixel. There is always some pixelization but the result is a smoother gradient of change.</p>
<p>There strategy used in minification is a little different. OpenGL supports a method known as mipmapping. The term mipmap comes from the latin acronym of multum in parvo, or &quot;much in little&quot;. The goal is to try to minimize the loss of information as the number of texels per pixel increase. The way this is done is to take the original texture and use performance-intensive methods to map the texture down to smaller and smaller textures, retaining as much information as possible. Then the set of &quot;maps&quot; are cached by OpenGL and it uses the one that is closest to a one-to-one mapping onto the pixels. This results in the least amount of information loss while using per-processed maps and reducing the overhead of having to do the mapping on the fly.</p>
<p>There are four types of mipmap filters supported by OpenGL</p>
<ul>
  <li>GL_NEAREST_MIPMAP_NEAREST
    <ul>
      <li>Chooses the mipmap that most closely matches the size of the pixel being textured and uses the GL_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value.</li>
    </ul>
  </li>
  <li>GL_NEAREST_MIPMAP_LINEAR
    <ul>
      <li>Chooses the mipmap that most closely matches the size of the pixel being textured and uses the GL_LINEAR criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value.</li>
    </ul>
  </li>
  <li>GL_LINEAR_MIPMAP_NEAREST
    <ul>
      <li>Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the GL_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.</li>
    </ul>
  </li>
  <li>GL_LINEAR_MIPMAP_LINEAR
    <ul>
      <li>Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the GL_LINEAR criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.</li>
    </ul>
  </li>
</ul>
<p>Whew. Lot of verbiage. The net net is that the first is the most performant and the last looks the best. Depending on the size and number of textures (and how patient you are) will determine which you will want to use.</p>
<p>In this (very simple) lesson, we'll be using a texture that is larger or roughly the same size as the surface being textured, so only the magnification filters actually can be seen to have an effect.
</p>
<p></p>

           
<p>And that's it!  Go on to the next page to see the actual rendered demo in all its texture filtered glory!</p>
</body>
</html>